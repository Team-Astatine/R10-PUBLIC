package org.Astatine.r10.Contents.Restricted.AntiExploit.ChatFlood;

import org.Astatine.r10.R10;
import org.Astatine.r10.Contents.EventRegister;
import org.Astatine.r10.Enumeration.Type.ColorType;
import org.Astatine.r10.Util.Function.StringComponentExchanger;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerKickEvent;

import io.papermc.paper.event.player.AsyncChatEvent;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.TextComponent;

public class RestrictedChatHandler extends StringComponentExchanger implements EventRegister {
    private Player player;
    private TextComponent currentChat;
    private RestrictedChatElement restrictedChatElement;

    private final AsyncChatEvent event;

    public RestrictedChatHandler(AsyncChatEvent event) {
        this.event = event;
        init();
        execute();
    }

    @Override
    public void init() {
        this.player = this.event.getPlayer();
        this.currentChat = (TextComponent) this.event.message();
        this.restrictedChatElement = RestrictedChatElement.getChatTotalStatus();
    }

    @Override
    public void execute() {
        // URL 포함 여부 체크
        if (this.restrictedChatElement.isExistURL(this.currentChat.content())) {
            Component comment = componentExchanger("주소를 포함한 채팅은 작성할 수 없습니다.", ColorType.RED);
            Bukkit.getScheduler().runTask(
                    R10.getPlugin(R10.class),
                    () -> this.player.kick(comment, PlayerKickEvent.Cause.SPAM)
            );
            this.event.setCancelled(true);
            return;
        }

        // 중복 채팅 여부 체크
        if (this.restrictedChatElement.isExistComment(new ChatMessage(this.player, this.currentChat.content()))) {
            this.player.sendMessage(componentExchanger("같은 채팅을 두번 칠 수 없습니다.", ColorType.RED));
            this.event.setCancelled(true);
            return;
        }

        // 정상 채팅 처리
        this.restrictedChatElement.clear();
        this.restrictedChatElement.addChat(new ChatMessage(this.player, this.currentChat.content()));
    }
}
